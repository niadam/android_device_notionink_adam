diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index 31d731e..c5888e2 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -17,7 +17,7 @@
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS

 // Uncomment this to remove support for HWC_DEVICE_API_VERSION_0_3 and older
-#define HWC_REMOVE_DEPRECATED_VERSIONS 1
+//#define HWC_REMOVE_DEPRECATED_VERSIONS 1

 #include <stdint.h>
 #include <stdio.h>
@@ -46,6 +46,12 @@
 #include "SurfaceFlinger.h"
 #include <utils/CallStack.h>
 
+#if HWC_REMOVE_DEPRECATED_VERSIONS
+// We need complete types to satisfy semantic checks, even though the code
+// paths that use these won't get executed at runtime.
+#include <hardware/hwcomposer_v0.h>
+#endif
+
 namespace android {
 
 #define MIN_HWC_HEADER_VERSION 0
@@ -75,6 +81,133 @@ static bool hwcHasApiVersion(const hwc_composer_device_1_t* hwc,
     return hwcApiVersion(hwc) >= (version & HARDWARE_API_VERSION_2_MAJ_MIN_MASK);
 }
 
+static int hwcPrepare(hwc_composer_device_1_t* hwc,
+        size_t numDisplays, hwc_display_contents_1_t** displays) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->prepare(hwc, numDisplays, displays);
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        hwc_layer_list_t* list0 =
+                reinterpret_cast<hwc_layer_list_t*>(displays[0]);
+        return hwc0->prepare(hwc0, list0);
+    }
+}
+
+static int hwcSet(hwc_composer_device_1_t* hwc, EGLDisplay dpy, EGLSurface sur,
+        size_t numDisplays, hwc_display_contents_1_t** displays) {
+    int err;
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        displays[0]->dpy = dpy;
+        displays[0]->sur = sur;
+        err = hwc->set(hwc, numDisplays, displays);
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        hwc_layer_list_t* list0 =
+                reinterpret_cast<hwc_layer_list_t*>(displays[0]);
+        err = hwc0->set(hwc0, dpy, sur, list0);
+    }
+    return err;
+}
+
+static int hwcEventControl(hwc_composer_device_1_t* hwc, int disp,
+        int event, int enabled) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->eventControl(hwc, disp, event, enabled);
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        return hwc0->methods->eventControl(hwc0, event, enabled);
+    }
+}
+
+static int hwcBlank(hwc_composer_device_1_t* hwc, int disp, int blank) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->blank(hwc, disp, blank);
+    } else {
+        if (blank) {
+            hwc_composer_device_t* hwc0 =
+                    reinterpret_cast<hwc_composer_device_t*>(hwc);
+            return hwc0->set(hwc0, NULL, NULL, NULL);
+        } else {
+            // HWC 0.x turns the screen on at the next set()
+            return NO_ERROR;
+        }
+    }
+}
+
+static void hwcRegisterProcs(hwc_composer_device_1_t* hwc,
+        hwc_procs_t const* procs) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        hwc->registerProcs(hwc, procs);
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        if (hwc0->registerProcs) {
+            hwc0->registerProcs(hwc0, procs);
+        }
+    }
+}
+
+static void hwcDump(hwc_composer_device_1_t* hwc, char* buff, int buff_len) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        if (hwc->dump) {
+            hwc->dump(hwc, buff, buff_len);
+        }
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        if (hwc0->dump) {
+            hwc0->dump(hwc0, buff, buff_len);
+        }
+    }
+}
+
+static size_t sizeofHwcLayerList(const hwc_composer_device_1_t* hwc,
+        size_t numLayers) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return sizeof(hwc_display_contents_1_t) +
+                numLayers * sizeof(hwc_layer_1_t);
+    } else {
+        return sizeof(hwc_layer_list_t) + numLayers * sizeof(hwc_layer_t);
+    }
+}
+
+static uint32_t& hwcFlags(hwc_composer_device_1_t* hwc,
+        hwc_display_contents_1_t* display) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return display->flags;
+    } else {
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(display);
+        return list0->flags;
+    }
+}
+
+static size_t& hwcNumHwLayers(hwc_composer_device_1_t* hwc,
+        hwc_display_contents_1_t* display) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return display->numHwLayers;
+    } else {
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(display);
+        return list0->numHwLayers;
+    }
+}
+
+static bool hwcHasEventControl(const hwc_composer_device_1_t* hwc) {
+    return hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_0_3);
+}
+
+static bool hwcHasRegisterProcs(hwc_composer_device_1_t* hwc) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->registerProcs;
+    } else {
+        hwc_composer_device_t* hwc0 =
+                reinterpret_cast<hwc_composer_device_t*>(hwc);
+        return hwc0->registerProcs;
+    }
+}
+
 // ---------------------------------------------------------------------------
 
 struct HWComposer::cb_context {
@@ -137,7 +270,7 @@ HWComposer::HWComposer(
         ALOGI("Using %s version %u.%u", HWC_HARDWARE_COMPOSER,
               (hwcApiVersion(mHwc) >> 24) & 0xff,
               (hwcApiVersion(mHwc) >> 16) & 0xff);
-        if (mHwc->registerProcs) {
+        if (hwcHasRegisterProcs(mHwc)) {
             mCBContext->hwc = this;
             mCBContext->procs.invalidate = &hook_invalidate;
             mCBContext->procs.vsync = &hook_vsync;
@@ -146,13 +279,15 @@ HWComposer::HWComposer(
             else
                 mCBContext->procs.hotplug = NULL;
             memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
-            mHwc->registerProcs(mHwc, &mCBContext->procs);
+            hwcRegisterProcs(mHwc, &mCBContext->procs);
         }
 
-        // don't need a vsync thread if we have a hardware composer
-        needVSyncThread = false;
-        // always turn vsync off when we start
-        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
+        if (hwcHasEventControl(mHwc)) {
+            // don't need a vsync thread if we have event control
+            needVSyncThread = false;
+            // always turn vsync off when we start
+            eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
+        }
 
         // the number of displays we actually have depends on the
         // hw composer version
@@ -233,7 +368,8 @@ void HWComposer::loadHwcModule()
         return;
     }
 
-    if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0) ||
+    if ((HWC_REMOVE_DEPRECATED_VERSIONS &&
+                !hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) ||
             hwcHeaderVersion(mHwc) < MIN_HWC_HEADER_VERSION ||
             hwcHeaderVersion(mHwc) > HWC_HEADER_VERSION) {
         ALOGE("%s device version %#x unsupported, will not be used",
@@ -455,7 +591,7 @@ void HWComposer::eventControl(int disp, int event, int enabled) {
         return;
     }
     status_t err = NO_ERROR;
-    if (mHwc && !mDebugForceFakeVSync) {
+    if (mHwc && hwcHasEventControl(mHwc) && !mDebugForceFakeVSync) {
         // NOTE: we use our own internal lock here because we have to call
         // into the HWC with the lock held, and we want to make sure
         // that even if HWC blocks (which it shouldn't), it won't
@@ -466,7 +602,7 @@ void HWComposer::eventControl(int disp, int event, int enabled) {
         const int32_t oldValue = mDisplayData[disp].events & eventBit;
         if (newValue != oldValue) {
             ATRACE_CALL();
-            err = mHwc->eventControl(mHwc, disp, event, enabled);
+            err = hwcEventControl(mHwc, disp, event, enabled);
             if (!err) {
                 int32_t& events(mDisplayData[disp].events);
                 events = (events & ~eventBit) | newValue;
@@ -495,8 +631,7 @@ status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
             numLayers++;
         }
         if (disp.capacity < numLayers || disp.list == NULL) {
-            size_t size = sizeof(hwc_display_contents_1_t)
-                    + numLayers * sizeof(hwc_layer_1_t);
+            size_t size = sizeofHwcLayerList(mHwc, numLayers);
             free(disp.list);
             disp.list = (hwc_display_contents_1_t*)malloc(size);
             disp.capacity = numLayers;
@@ -519,9 +654,11 @@ status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
             disp.framebufferTarget->acquireFenceFd = -1;
             disp.framebufferTarget->releaseFenceFd = -1;
         }
-        disp.list->retireFenceFd = -1;
-        disp.list->flags = HWC_GEOMETRY_CHANGED;
-        disp.list->numHwLayers = numLayers;
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            disp.list->retireFenceFd = -1;
+        }
+        hwcFlags(mHwc, disp.list) = HWC_GEOMETRY_CHANGED;
+        hwcNumHwLayers(mHwc, disp.list) = numLayers;
     }
     return NO_ERROR;
 }
@@ -568,7 +705,7 @@ status_t HWComposer::prepare() {
         }
         if (!disp.connected && disp.list != NULL) {
             ALOGW("WARNING: disp %d: connected, non-null list, layers=%d",
-                  i, disp.list->numHwLayers);
+                  i, hwcNumHwLayers(mHwc, disp.list));
         }
         mLists[i] = disp.list;
         if (mLists[i]) {
@@ -579,39 +716,58 @@ status_t HWComposer::prepare() {
                 // garbage data to catch improper use
                 mLists[i]->dpy = (hwc_display_t)0xDEADBEEF;
                 mLists[i]->sur = (hwc_surface_t)0xDEADBEEF;
-            } else {
+            } else if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
                 mLists[i]->dpy = EGL_NO_DISPLAY;
                 mLists[i]->sur = EGL_NO_SURFACE;
             }
         }
     }
 
-    int err = mHwc->prepare(mHwc, mNumDisplays, mLists);
+    int err = hwcPrepare(mHwc, mNumDisplays, mLists);
     ALOGE_IF(err, "HWComposer: prepare failed (%s)", strerror(-err));
 
     if (err == NO_ERROR) {
         // here we're just making sure that "skip" layers are set
         // to HWC_FRAMEBUFFER and we're also counting how many layers
         // we have of each type.
-        for (size_t i=0 ; i<mNumDisplays ; i++) {
-            DisplayData& disp(mDisplayData[i]);
-            disp.hasFbComp = false;
-            disp.hasOvComp = false;
-            if (disp.list) {
-                for (size_t i=0 ; i<disp.list->numHwLayers ; i++) {
-                    hwc_layer_1_t& l = disp.list->hwLayers[i];
-
-                    //ALOGD("prepare: %d, type=%d, handle=%p",
-                    //        i, l.compositionType, l.handle);
-
-                    if (l.flags & HWC_SKIP_LAYER) {
-                        l.compositionType = HWC_FRAMEBUFFER;
-                    }
-                    if (l.compositionType == HWC_FRAMEBUFFER) {
-                        disp.hasFbComp = true;
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            for (size_t i=0 ; i<mNumDisplays ; i++) {
+                DisplayData& disp(mDisplayData[i]);
+                disp.hasFbComp = false;
+                disp.hasOvComp = false;
+                if (disp.list) {
+                    for (size_t i=0 ; i<hwcNumHwLayers(mHwc, disp.list) ; i++) {
+                        hwc_layer_1_t& l = disp.list->hwLayers[i];
+                        if (l.flags & HWC_SKIP_LAYER) {
+                            l.compositionType = HWC_FRAMEBUFFER;
+                        }
+                        if (l.compositionType == HWC_FRAMEBUFFER) {
+                            disp.hasFbComp = true;
+                        }
+                        if (l.compositionType == HWC_OVERLAY) {
+                            disp.hasOvComp = true;
+                        }
                     }
-                    if (l.compositionType == HWC_OVERLAY) {
-                        disp.hasOvComp = true;
+                }
+            }
+        } else {
+            for (size_t i=0 ; i<mNumDisplays ; i++) {
+                DisplayData& disp(mDisplayData[i]);
+                disp.hasFbComp = false;
+                disp.hasOvComp = false;
+                if (disp.list) {
+                    for (size_t i=0 ; i<hwcNumHwLayers(mHwc, disp.list) ; i++) {
+                        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(disp.list);
+                        hwc_layer_t& l = list0->hwLayers[i];
+                        if (l.flags & HWC_SKIP_LAYER) {
+                            l.compositionType = HWC_FRAMEBUFFER;
+                        }
+                        if (l.compositionType == HWC_FRAMEBUFFER) {
+                            disp.hasFbComp = true;
+                        }
+                        if (l.compositionType == HWC_OVERLAY) {
+                            disp.hasOvComp = true;
+                        }
                     }
                 }
             }
@@ -651,7 +807,8 @@ int HWComposer::getAndResetReleaseFenceFd(int32_t id) {
 status_t HWComposer::commit() {
     int err = NO_ERROR;
     if (mHwc) {
-        if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0) &&
+                !hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
             // On version 1.0, the OpenGL ES target surface is communicated
             // by the (dpy, sur) fields and we are guaranteed to have only
             // a single display.
@@ -659,16 +816,20 @@ status_t HWComposer::commit() {
             mLists[0]->sur = eglGetCurrentSurface(EGL_DRAW);
         }
 
-        err = mHwc->set(mHwc, mNumDisplays, mLists);
+        void* fbDisplay = eglGetCurrentDisplay();
+        void* fbSurface = eglGetCurrentSurface(EGL_DRAW);
+        err = hwcSet(mHwc, fbDisplay, fbSurface, mNumDisplays, mLists);
 
         for (size_t i=0 ; i<mNumDisplays ; i++) {
             DisplayData& disp(mDisplayData[i]);
             if (disp.list) {
-                if (disp.list->retireFenceFd != -1) {
-                    close(disp.list->retireFenceFd);
-                    disp.list->retireFenceFd = -1;
+                if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+                    if (disp.list->retireFenceFd != -1) {
+                        close(disp.list->retireFenceFd);
+                        disp.list->retireFenceFd = -1;
+                    }
                 }
-                disp.list->flags &= ~HWC_GEOMETRY_CHANGED;
+                hwcFlags(mHwc, disp.list) &= ~HWC_GEOMETRY_CHANGED;
             }
         }
     }
@@ -679,7 +840,7 @@ status_t HWComposer::release(int disp) {
     LOG_FATAL_IF(disp >= HWC_NUM_DISPLAY_TYPES);
     if (mHwc) {
         eventControl(disp, HWC_EVENT_VSYNC, 0);
-        return (status_t)mHwc->blank(mHwc, disp, 1);
+        return (status_t)hwcBlank(mHwc, disp, 1);
     }
     return NO_ERROR;
 }
@@ -687,7 +848,7 @@ status_t HWComposer::release(int disp) {
 status_t HWComposer::acquire(int disp) {
     LOG_FATAL_IF(disp >= HWC_NUM_DISPLAY_TYPES);
     if (mHwc) {
-        return (status_t)mHwc->blank(mHwc, disp, 0);
+        return (status_t)hwcBlank(mHwc, disp, 0);
     }
     return NO_ERROR;
 }
@@ -866,6 +1027,97 @@ public:
     }
 };
 
+// #if !HWC_REMOVE_DEPRECATED_VERSIONS
+/*
+ * Concrete implementation of HWCLayer for HWC_DEVICE_API_VERSION_0_3
+ * This implements the HWCLayer side of HWCIterableLayer.
+ */
+class HWCLayerVersion0 : public Iterable<HWCLayerVersion0, hwc_layer_t> {
+public:
+    HWCLayerVersion0(hwc_layer_t* layer)
+        : Iterable<HWCLayerVersion0, hwc_layer_t>(layer) { }
+
+    virtual int32_t getCompositionType() const {
+        return getLayer()->compositionType;
+    }
+    virtual uint32_t getHints() const {
+        return getLayer()->hints;
+    }
+    virtual int getAndResetReleaseFenceFd() {
+        // not supported on VERSION_03
+        return -1;
+    }
+    virtual void setAcquireFenceFd(int fenceFd) {
+        if (fenceFd != -1) {
+            ALOGE("HWC 0.x can't handle acquire fences");
+            close(fenceFd);
+        }
+    }
+
+    virtual void setDefaultState() {
+        getLayer()->compositionType = HWC_FRAMEBUFFER;
+        getLayer()->hints = 0;
+        getLayer()->flags = HWC_SKIP_LAYER;
+        getLayer()->handle = 0;
+        getLayer()->transform = 0;
+        getLayer()->blending = HWC_BLENDING_NONE;
+        getLayer()->visibleRegionScreen.numRects = 0;
+        getLayer()->visibleRegionScreen.rects = NULL;
+    }
+    virtual void setSkip(bool skip) {
+        if (skip) {
+            getLayer()->flags |= HWC_SKIP_LAYER;
+        } else {
+            getLayer()->flags &= ~HWC_SKIP_LAYER;
+        }
+    }
+    virtual void setBlending(uint32_t blending) {
+        getLayer()->blending = blending;
+    }
+    virtual void setTransform(uint32_t transform) {
+        getLayer()->transform = transform;
+    }
+    virtual void setFrame(const Rect& frame) {
+        reinterpret_cast<Rect&>(getLayer()->displayFrame) = frame;
+    }
+    virtual void setCrop(const Rect& crop) {
+        reinterpret_cast<Rect&>(getLayer()->sourceCrop) = crop;
+    }
+    virtual void setVisibleRegionScreen(const Region& reg) {
+        /*
+        getLayer()->visibleRegionScreen.rects =
+                reinterpret_cast<hwc_rect_t const *>(
+                        reg.getArray(&getLayer()->visibleRegionScreen.numRects));
+        */
+        // Region::getSharedBuffer creates a reference to the underlying
+        // SharedBuffer of this Region, this reference is freed
+        // in onDisplayed()
+        hwc_region_t& visibleRegion = getLayer()->visibleRegionScreen;
+        SharedBuffer const* sb = reg.getSharedBuffer(&visibleRegion.numRects);
+        visibleRegion.rects = reinterpret_cast<hwc_rect_t const *>(sb->data());
+    }
+    virtual void setBuffer(const sp<GraphicBuffer>& buffer) {
+        if (buffer == 0 || buffer->handle == 0) {
+            getLayer()->compositionType = HWC_FRAMEBUFFER;
+            getLayer()->flags |= HWC_SKIP_LAYER;
+            getLayer()->handle = 0;
+        } else {
+            getLayer()->handle = buffer->handle;
+        }
+    }
+    virtual void onDisplayed() {
+        hwc_region_t& visibleRegion = getLayer()->visibleRegionScreen;
+        SharedBuffer const* sb = SharedBuffer::bufferFromData(visibleRegion.rects);
+        if (sb) {
+            sb->release();
+            // not technically needed but safer
+            visibleRegion.numRects = 0;
+            visibleRegion.rects = NULL;
+        }
+    }
+};
+// #endif // !HWC_REMOVE_DEPRECATED_VERSIONS
+
 /*
  * returns an iterator initialized at a given index in the layer list
  */
@@ -874,10 +1126,16 @@ HWComposer::LayerListIterator HWComposer::getLayerIterator(int32_t id, size_t in
         return LayerListIterator();
     }
     const DisplayData& disp(mDisplayData[id]);
-    if (!mHwc || !disp.list || index > disp.list->numHwLayers) {
+    if (!mHwc || !disp.list || index > hwcNumHwLayers(mHwc, disp.list)) {
         return LayerListIterator();
     }
-    return LayerListIterator(new HWCLayerVersion1(disp.list->hwLayers), index);
+    if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return LayerListIterator(new HWCLayerVersion1(disp.list->hwLayers),
+                index);
+    } else {
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(disp.list);
+        return LayerListIterator(new HWCLayerVersion0(list0->hwLayers), index);
+    }
 }
 
 /*
@@ -895,7 +1153,7 @@ HWComposer::LayerListIterator HWComposer::end(int32_t id) {
     if (uint32_t(id) <= 31 && mAllocatedDisplayIDs.hasBit(id)) {
         const DisplayData& disp(mDisplayData[id]);
         if (mHwc && disp.list) {
-            numLayers = disp.list->numHwLayers;
+            numLayers = hwcNumHwLayers(mHwc, disp.list);
             if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
                 // with HWC 1.1, the last layer is always the HWC_FRAMEBUFFER_TARGET,
                 // which we ignore when iterating through the layer list.
@@ -928,14 +1186,22 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
             if (disp.list && disp.connected) {
                 result.appendFormat(
                         "  numHwLayers=%u, flags=%08x\n",
-                        disp.list->numHwLayers, disp.list->flags);
+                        hwcNumHwLayers(mHwc, disp.list), hwcFlags(mHwc, disp.list));
 
                 result.append(
                         "    type    |  handle  |   hints  |   flags  | tr | blend |  format  |       source crop         |           frame           name \n"
                         "------------+----------+----------+----------+----+-------+----------+---------------------------+--------------------------------\n");
                 //      " __________ | ________ | ________ | ________ | __ | _____ | ________ | [_____,_____,_____,_____] | [_____,_____,_____,_____]
-                for (size_t i=0 ; i<disp.list->numHwLayers ; i++) {
-                    const hwc_layer_1_t&l = disp.list->hwLayers[i];
+                for (size_t i=0 ; i<hwcNumHwLayers(mHwc, disp.list) ; i++) {
+                    hwc_layer_1_t const* lp;
+                    if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+                        lp = &disp.list->hwLayers[i];
+                    } else {
+                        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(disp.list);
+                        // FIXME: here we rely on hwc_layer_1_t and hwc_layer_t having the same layout
+                        lp = reinterpret_cast<hwc_layer_1_t const*>(&list0->hwLayers[i]);
+                    }
+                    const hwc_layer_1_t&l = *lp;
                     int32_t format = -1;
                     String8 name("unknown");
 
@@ -978,8 +1244,8 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
         }
     }
 
-    if (mHwc && mHwc->dump) {
-        mHwc->dump(mHwc, buffer, SIZE);
+    if (mHwc) {
+        hwcDump(mHwc, buffer, SIZE);
         result.append(buffer);
     }
 }
